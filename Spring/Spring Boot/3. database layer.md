## ORM
- short for Object-to-Relational Mapping
- mapping between Java class and database table

---
## JPA
- short for Jakarta Persistence API
- standard API for ORM that defines a set of interfaces and requires an implementation to be usable

---
## hibernate
- a framework for persisting/saving Java objects in a database
- handles all of the low-level SQL
- provides Object-to-Relational Mapping (ORM)
- one of the many implementations of JPA

---
## JDBC
- short for Java Database Connectivity
- allows Java programs to access database
- Hibernate and JPA uses JDBC for all database communications

---
## connect to db
- to connect to a database add the following entries in `application.properties`
```properties
spring.datasource.url=jdbc:mysql://localhost:3306/student_tracker
spring.datasource.username=drchad
spring.datasource.password=pass123
```
- **`CommandLineRunner`** -> hook provided by Spring that executes after all beans have been loaded
```java
@Bean
public CommandLineRunner commandLineRunner(String[] args) {
	return runner -> System.out.println("Hello World");
}
```

---
## entity class
- java class that is mapped to a database table
- `@Entity` -> indicates that class is correlated with a table in the database
- at minimum an entity must be annotated with `@Entity` and must have a public or protected no-arg constructor
 - `@Table(name="tableName)"` -> 
	 - used to specify the details of the table that will be used like table name, schema, and other attributes
	 - optional but if not defined, the table name is the same as the class
 - `@Id` -> used to define the primary key for the entity
 - `@Column(name="columnName")` -> 
	 - allows to customize the mapping of a field
	 - optional but if not defined, the column name is the same name as Java field
 - `@GeneratedValue(strategy=GenerationType.IDENTITY)` -> 
	 - indicates that the value for the column will be automatically generated by the database
	 - there are multiple types of strategies ->
		 - `AUTO` -> pick an appropriate strategy for the particular database
		 - `IDENTITY` -> assign primary keys using database identity column
		 - `SEQUENCE`  -> assign primary keys using a database sequence
		 - `TABLE` -> assign primary keys using an underlying database table to ensure uniqueness
	 - it's also possible to define a custom generation strategy by creating an implementation of `org.hibernate.id.IdentifierGenerator` and overriding the `public Serializable generate()` method
```java
@Entity  
@Table(name = "student")  
public class Student {  
  
    @Id  
    @GeneratedValue(strategy = GenerationType.IDENTITY)  
    @Column(name = "id")  
    private int id;

}
```
- create table from Java code ->
	- Spring can automagically create tables and columns using the entity class
	- some of the property values include
		- `none` -> no action will be performed
		- `create-only` -> tables are only created
		- `drop` -> tables are dropped
		- `create` -> tables dropped then created
		- `create-drop` -> on shutdown, tables are dropped
		- `validate` -> validates the table schema
		- `update` -> update the table schema
```properties
spring.jpa.hibernate.ddl-auto=PROPERTY_VALUE
```

---
## data access object (DAO)
- responsible for interfacing with the database
- entity manager -> 
	- provides methods for interacting with a relational database to perform operations on entities
	- responsible for managing the lifecycle of JPA entities such as persisting, retrieving, updating, and removing entities
	- provides methods for beginning, committing, and rolling back transactions
	- allows developers to to execute JPQL (Java Persistence Query Language) queries to retrieve data from the database
	- helps manage relationships between entities
	- helps manage concurrent access
- `@Repository` -> sub-annotation of `@Component` and primarily used to annotate DAO's
```java
@Repository  
public class StudentDAOImpl implements StudentDAO {  
  
    private EntityManager entityManager;  
  
    @Autowired  
    public StudentDAOImpl(EntityManager entityManager) {  
        this.entityManager = entityManager;  
    }  
  
}
```
- `@Transactional` -> automagically begins and ends a transaction; not needed when performing a read functionality
- insert -> use `persist` to save the object
```java
@Transactional  
@Override    
public void save(Student student) {  
	entityManager.persist(student);  
}  
```
- read -> use `find` to search using an id
```java
@Override  
public Student findById(Integer id) {  
    return entityManager.find(Student.class, id);  
}
```
- update -> use `merge` to update an entity
```java
@Transactional
@Override
public void update(Student student) {
	entityManager.merge(student);
}
```
- delete -> use `remove` to delete an entity
```java
@Transactional
@Override
public void delete(Student student) {
	entityManager.remove(student);
}
```

---
## JPQL
- short for Java Persistence Query Language
- query language for retrieving objects similar to SQL
- based on entity name and fields compared to table and column
```java
// note that Student is an entity, not a table
TypedQuery<Student> query = entityManager.createQuery(
	"FROM Student", Student.class
)
List<Student> students = query.getResultList();
```
- named parameter -> prefixed with `:` and set later
```java
public List<Student> findByLastName(String theLastName) {
	TypedQuery<Student> query = entityManager.createQuery(
		"FROM Student WHERE lastName=:data", Student.class
	);
	query.setParameter("data", theLastName)
	return query.getResultList();
}
```
- write to database -> requires `executeUpdate()` and it returns the number of rows that were affected
```java
@Transactional  
@Override  
public int deleteAll() {  
    int rowsDeleted = entityManager.createQuery(
	    "DELETE FROM Student"
	).executeUpdate();  
    return rowsDeleted;  
}
```
